import re


# ДОБАВИТЬ везде: аннотации типов параметров всех методов и возвращаемых значений всех не встроенных методов — это обязательная часть каждого задания, если вы возьмёте на себя труд прочитать файл задания до конца
# КОММЕНТАРИЙ: для структурных классов особенно важно видеть взаимные согласования типов — для этого и служат аннотации


class TextParser:
    """Парсер текстовых данных в некой системе."""
    def __init__(self, text: str):
        tmp = re.sub(r'\W', ' ', text.lower())
        tmp = re.sub(r' +', ' ', tmp).strip()
        self.text = tmp

    
    def get_processed_text(self, processor) -> None:
        """Вызывает метод класса обработчика.
        
        :param processor: экземпляр класса обработчика
        """
        result = processor.process_text(self.text)
        print(*result, sep='\n')


class WordCounter: 
    """Счётчик частотности слов в тексте."""
    def __init__(self, text: str) -> None:
        """Обрабатывает переданный текст и создаёт словарь с частотой слов."""
        self.__words = dict()
        for word in text.split():
            self.__words[word] = self.__words.get(word, 0) + 1
            
    def get_count(self, word: str):
        """Возвращает частоту переданного слова."""
        return self.__words.get(word, 0)
        
    def get_all_words(self):
        """Возвращает словарь с частотой слов."""
        return self.__words.copy()


# ИСПРАВИТЬ везде: имена идентификаторов обязаны нести однозначную смысловую нагрузку — имена переменных obj, words, keys, pars, word не сообразуются с объектами, ассоциированными с соответствующими переменными


class Adapter:
    """Адаптер обработчика"""

    def __init__(self, obj):
        # КОММЕНТАРИЙ: сохраняя в качестве атрибута объект класса, а не объект экземпляра необходимо быть аккуратным: такой подход имеет право на жизнь, и в данном случае он работает, но это не всегда желательный вариант — например, если в итеративном процессе одинаковый экземпляр будет создаваться на каждой итерации, что приведёт к бессмысленному падению производительности
        self.obj = obj

    # Реализация интерфейса обработчика, требуемого системой.
    def process_text(self, text):
        words = self.obj(text)
        keys = words.get_all_words()
        # УДАЛИТЬ: действие не имеет смысла
        list_keys = [i for i in keys]
        # ИСПОЛЬЗОВАТЬ: при итерации по словарю в переменную цикла и так возвращаются именно ключи
        return sorted(keys, key=lambda x: words.get_count(x))


# КОММЕНТАРИЙ: при ручном тестировании эффективнее использовать для тестов такие данные, обработка которых проверяется человеком быстро и просто — так, здесь стоило взять более короткий текст с очевидно повторяющимися словами, например: "раз, два, три, четыре, три, два, раз и снова раз..."
text = '''  Практический опыт показывает, что рамки и место обучения кадров способствует 
            повышению актуальности позиций, занимаемых участниками в отношении поставленных задач. 
            Повседневная практика показывает, что новая модель организационной деятельности напрямую 
            зависит от существующих финансовых и административных условий? Таким образом, социально-экономическое 
            развитие позволяет выполнить важнейшие задания по разработке существующих финансовых и административных условий.'''

pars = TextParser(text)
word = WordCounter
adapter = Adapter(word)
pars.get_processed_text(adapter)


# stdout:

# практический
# опыт
# рамки
# место
# обучения
# кадров
# способствует
# повышению
# актуальности
# позиций
# занимаемых
# участниками
# в
# отношении
# поставленных
# задач
# повседневная
# практика
# новая
# модель
# организационной
# деятельности
# напрямую
# зависит
# от
# таким
# образом
# социально
# экономическое
# развитие
# позволяет
# выполнить
# важнейшие
# задания
# по
# разработке
# показывает
# что
# существующих
# финансовых
# административных
# условий
# и


# ИТОГ: неплохо, но можно лучше — 4/7
